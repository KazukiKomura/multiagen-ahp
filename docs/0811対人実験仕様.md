# 人間1名+AI3名 n=4ゲーム詳細仕様

## ゲーム概要

### 基本設定
- **参加者**: 人間1名（プレイヤー）+ AI3名（ボット）
- **目標**: 3つの大学から最適な選択をグループで決定
- **時間**: 約15分（設定3分 + ゲーム12分）
- **ラウンド数**: 12ラウンド
- **勝利条件**: 個人満足度 + グループ合意度の最大化

### ゲームフロー概要
```
事前設定(3分) → メインゲーム(12分) → 結果表示(2分)
     ↓              ↓                    ↓
   AHP重み設定    12ラウンドの        最終ランキング
   Veto基準選択   提案→判断→更新      満足度スコア
```

## Phase 1: 事前設定（3分）

### 1.1 チュートリアル（1分）
```html
<!-- Welcome Screen -->
<div class="tutorial">
  <h2>大学選択グループ決定ゲーム</h2>
  <p>あなたは3人のAI参加者と一緒に、3つの大学の中から
     グループで最適な選択肢を決定します。</p>
  
  <div class="game-elements">
    <h3>ゲームの要素:</h3>
    <ul>
      <li>🎯 <strong>基準</strong>: 学術レベル、費用、立地、就職実績</li>
      <li>🏫 <strong>選択肢</strong>: 3つの大学（A大学～C大学）</li>
      <li>💭 <strong>提案</strong>: AIと協力して重要度や評価を調整</li>
      <li>🤝 <strong>合意</strong>: グループ全体での最適解を目指す</li>
    </ul>
  </div>
</div>
```

### 1.2 AHP 一対比較（基準 & 各代替案）〈2分〉

以下の 2 ステップで計 18 (= 3 × 6) 個の比較を行います。

1. **基準間比較（従来通り 6 個）** – 4 つの基準同士の重要度を決定。
2. **代替案ごとの基準比較（3 案 × 6 ペア = 18 個）** – 各大学について「どの基準がどの程度重要か」を個別に評価。

```javascript
// AHP 一対比較インターフェース（基準 + 代替案別）
const PairwiseComparison = () => {
  const criteria = ["学術レベル", "費用", "立地", "就職実績"];
  const alternatives = ["A大学", "B大学", "C大学"];

  // 基準間ペア (4C2 = 6)
  const critPairs = [
    ["学術レベル", "費用"], ["学術レベル", "立地"], ["学術レベル", "就職実績"],
    ["費用", "立地"], ["費用", "就職実績"], ["立地", "就職実績"]
  ];

  return (
    <div className="pairwise-setup">
      {/* --------- Step 1: 基準間比較 --------- */}
      <h3>① 基準の重要度比較</h3>
      <p>各ペアについて、どちらがどの程度重要かを選択してください</p>

      {critPairs.map((pair, idx) => (
        <ComparisonRow key={`crit_${idx}`} pair={pair} namePrefix={`crit_${idx}`} />
      ))}

      {/* --------- Step 2: 代替案別の基準比較 --------- */}
      <h3 style={{marginTop: "2rem"}}>② 各代替案に対する基準比較</h3>
      <p>各大学について、基準同士の相対的重要度を評価してください（計 18 個）</p>

      {alternatives.map((alt, altIdx) => (
        <div key={altIdx} className="alt-block">
          <h4>{alt}</h4>
          {critPairs.map((pair, idx) => (
            <ComparisonRow
              key={`alt_${altIdx}_${idx}`}
              pair={pair}
              namePrefix={`alt_${altIdx}_${idx}`}
              labelLeft={`${pair[0]} @${alt}`}
              labelRight={`${pair[1]} @${alt}`}
            />
          ))}
        </div>
      ))}

      {/* プレビュー & 整合性 */}
      <WeightPreview criteria={criteria} />
    </div>
  );
};

/* --- 補助コンポーネント --- */
const ComparisonRow = ({pair, namePrefix, labelLeft = pair[0], labelRight = pair[1]}) => (
  <div className="comparison-row">
    <span className="criterion">{labelLeft}</span>
    <div className="comparison-scale">
      {[9,7,5,3,1,1,3,5,7,9].map((val, i) => (
        <label key={i}>
          <input type="radio" name={namePrefix} value={val} />
          {val === 1 ? "同程度" : i < 5 ? `${val}倍重要` : `1/${val}倍重要`}
        </label>
      ))}
    </div>
    <span className="criterion">{labelRight}</span>
  </div>
);

const WeightPreview = ({criteria}) => (
  <div className="weight-preview">
    <h4>計算された重要度:</h4>
    {/* …基準と代替案別ウエイトをここに可視化… */}
    <div className="consistency">整合性: {/* CI 値を表示 */}</div>
  </div>
);
```

### 1.3 Veto基準選択（1分）
```javascript
const VetoSelection = () => {
  return (
    <div className="veto-setup">
      <h3>最重要基準の選択</h3>
      <p>絶対に重要度を下げたくない基準を1つ選択してください</p>
      
      <div className="veto-options">
        {criteria.map((crit, i) => (
          <div key={i} className="veto-option">
            <input type="radio" name="veto" value={i} id={`veto_${i}`} />
            <label htmlFor={`veto_${i}`}>
              <div className="criterion-card">
                <h4>{crit}</h4>
                <p className="current-weight">現在の重要度: {(weights[i]*100).toFixed(1)}%</p>
                <div className="protection-note">
                  ⚠️ この基準の重要度を下げる提案は自動拒否されます
                </div>
              </div>
            </label>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## Phase 2: メインゲーム（12分）

### 2.1 ゲーム状態表示
```javascript
const GameState = () => {
  return (
    <div className="game-interface">
      <div className="header-info">
        <div className="round-info">
          <span>ラウンド {currentRound} / 12</span>
          <div className="time-remaining">{timeRemaining}</div>
        </div>
        <div className="scores">
          <span>個人満足度: {personalSatisfaction.toFixed(1)}</span>
          <span>グループ合意度: {groupConsensus.toFixed(1)}</span>
        </div>
      </div>
      
      <div className="main-content">
        <div className="left-panel">
          <CurrentWeights />
          <UniversityRanking />
        </div>
        <div className="center-panel">
          <AIProposal />
          <ActionSelection />
        </div>
        <div className="right-panel">
          <GroupStatus />
          <RecentActivity />
        </div>
      </div>
    </div>
  );
};
```

### 2.2 現在状態表示
```javascript
const CurrentWeights = () => {
  return (
    <div className="current-weights">
      <h3>現在の重要度</h3>
      <div className="weight-comparison">
        <div className="own-weights">
          <h4>あなた</h4>
          {criteria.map((crit, i) => (
            <div key={i} className="weight-row">
              <span>{crit}</span>
              <div className="weight-bar own">
                <div style={{width: `${humanWeights[i]*100}%`}}></div>
              </div>
              <span>{(humanWeights[i]*100).toFixed(1)}%</span>
            </div>
          ))}
        </div>
        
        <div className="group-weights">
          <h4>グループ平均</h4>
          {criteria.map((crit, i) => (
            <div key={i} className="weight-row">
              <span>{crit}</span>
              <div className="weight-bar group">
                <div style={{width: `${groupWeights[i]*100}%`}}></div>
              </div>
              <span>{(groupWeights[i]*100).toFixed(1)}%</span>
              <span className={`diff ${humanWeights[i] > groupWeights[i] ? 'higher' : 'lower'}`}>
                {humanWeights[i] > groupWeights[i] ? '↑' : '↓'}
                {Math.abs(humanWeights[i] - groupWeights[i] * 100).toFixed(1)}%
              </span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};
```

### 2.3 大学ランキング表示
```javascript
const UniversityRanking = () => {
  const personalRanking = calculatePersonalRanking(humanWeights, humanEvaluations);
  const groupRanking = calculateGroupRanking(groupWeights, groupEvaluations);
  
  return (
    <div className="university-ranking">
      <h3>大学ランキング</h3>
      <div className="ranking-comparison">
        <div className="personal-ranking">
          <h4>あなたの順位</h4>
          {personalRanking.map((uni, rank) => (
            <div key={rank} className="rank-item">
              <span className="rank">#{rank + 1}</span>
              <span className="university">{uni.name}</span>
              <span className="score">{uni.score.toFixed(2)}</span>
            </div>
          ))}
        </div>
        
        <div className="group-ranking">
          <h4>グループ順位</h4>
          {groupRanking.map((uni, rank) => (
            <div key={rank} className="rank-item">
              <span className="rank">#{rank + 1}</span>
              <span className="university">{uni.name}</span>
              <span className="score">{uni.score.toFixed(2)}</span>
            </div>
          ))}
        </div>
      </div>
      
      <div className="consensus-indicator">
        <span>ランキング一致度: </span>
        <div className="consensus-bar">
          <div style={{width: `${rankingConsensus*100}%`}}></div>
        </div>
        <span>{(rankingConsensus*100).toFixed(1)}%</span>
      </div>
    </div>
  );
};
```

### 2.4 AI提案表示
```javascript
const AIProposal = () => {
  const aiSuggestion = generateAISuggestion(gameState);
  
  return (
    <div className="ai-proposal">
      <h3>🤖 AI参加者からの提案</h3>
      
      <div className="proposal-card">
        <div className="proposal-header">
          <span className="proposer">AI-{aiSuggestion.proposer}</span>
          <span className="proposal-type">{aiSuggestion.type}</span>
        </div>
        
        <div className="proposal-content">
          <h4>{aiSuggestion.title}</h4>
          <p>{aiSuggestion.description}</p>
          
          <div className="expected-impact">
            <h5>予想される効果:</h5>
            <ul>
              <li>個人満足度: {aiSuggestion.impact.personal > 0 ? '↑' : '↓'} 
                  {Math.abs(aiSuggestion.impact.personal).toFixed(2)}</li>
              <li>グループ合意: {aiSuggestion.impact.consensus > 0 ? '↑' : '↓'} 
                  {Math.abs(aiSuggestion.impact.consensus).toFixed(2)}</li>
            </ul>
          </div>
        </div>
        
        <div className="proposal-actions">
          <button className="accept-btn" onClick={() => acceptProposal(aiSuggestion)}>
            📝 この提案を参考にする
          </button>
          <button className="ignore-btn" onClick={() => ignoreProposal()}>
            🚫 無視して自分で決める
          </button>
        </div>
      </div>
    </div>
  );
};
```

### 2.5 アクション選択インターフェース
```javascript
const ActionSelection = () => {
  const [selectedCategory, setSelectedCategory] = useState('weight');
  const [selectedCriterion, setSelectedCriterion] = useState(0);
  const [selectedDirection, setSelectedDirection] = useState(1);
  const [selectedMagnitude, setSelectedMagnitude] = useState(2.0);
  
  return (
    <div className="action-selection">
      <h3>あなたの行動選択</h3>
      
      <div className="action-categories">
        <button 
          className={selectedCategory === 'weight' ? 'active' : ''}
          onClick={() => setSelectedCategory('weight')}
        >
          ⚖️ 基準重要度の調整
        </button>
        <button 
          className={selectedCategory === 'evaluation' ? 'active' : ''}
          onClick={() => setSelectedCategory('evaluation')}
        >
          🏫 大学評価の調整
        </button>
      </div>
      
      {selectedCategory === 'weight' && (
        <div className="weight-actions">
          <div className="criterion-selection">
            <h4>調整する基準:</h4>
            {criteria.map((crit, i) => (
              <button 
                key={i}
                className={selectedCriterion === i ? 'selected' : ''}
                onClick={() => setSelectedCriterion(i)}
                disabled={vetoIndex === i && selectedDirection === -1}
              >
                {crit}
                {vetoIndex === i && <span className="veto-mark">🛡️</span>}
              </button>
            ))}
          </div>
          
          <div className="direction-selection">
            <h4>調整方向:</h4>
            <button 
              className={selectedDirection === 1 ? 'selected' : ''}
              onClick={() => setSelectedDirection(1)}
            >
              ⬆️ 重要度を上げる
            </button>
            <button 
              className={selectedDirection === -1 ? 'selected' : ''}
              onClick={() => setSelectedDirection(-1)}
              disabled={vetoIndex === selectedCriterion}
            >
              ⬇️ 重要度を下げる
              {vetoIndex === selectedCriterion && <span className="blocked">（Veto保護中）</span>}
            </button>
          </div>
        </div>
      )}
      
      {selectedCategory === 'evaluation' && (
        <div className="evaluation-actions">
          <div className="university-selection">
            <h4>調整する大学:</h4>
            {universities.map((uni, i) => (
              <button 
                key={i}
                className={selectedUniversity === i ? 'selected' : ''}
                onClick={() => setSelectedUniversity(i)}
              >
                {uni.name}
              </button>
            ))}
          </div>
          
          <div className="criterion-selection">
            <h4>評価基準:</h4>
            {criteria.map((crit, i) => (
              <button 
                key={i}
                className={selectedCriterion === i ? 'selected' : ''}
                onClick={() => setSelectedCriterion(i)}
              >
                {crit}
              </button>
            ))}
          </div>
        </div>
      )}
      
      <div className="magnitude-selection">
        <h4>調整の強度:</h4>
        <div className="magnitude-options">
          {[1.0, 2.0, 3.0].map(mag => (
            <button 
              key={mag}
              className={selectedMagnitude === mag ? 'selected' : ''}
              onClick={() => setSelectedMagnitude(mag)}
            >
              {mag === 1.0 ? '弱く' : mag === 2.0 ? '中程度' : '強く'}
            </button>
          ))}
        </div>
      </div>
      
      <div className="action-preview">
        <h4>実行予定の行動:</h4>
        <div className="preview-text">
          {generateActionDescription(selectedCategory, selectedCriterion, selectedDirection, selectedMagnitude)}
        </div>
        
        <button 
          className="execute-btn"
          onClick={executeAction}
          disabled={!isValidAction()}
        >
          🚀 この行動を実行
        </button>
      </div>
    </div>
  );
};
```

### 2.6 グループ状況表示
```javascript
const GroupStatus = () => {
  return (
    <div className="group-status">
      <h3>🤝 グループ状況</h3>
      
      <div className="ai-participants">
        {aiParticipants.map((ai, i) => (
          <div key={i} className="ai-card">
            <div className="ai-header">
              <span className="ai-name">AI-{i+1}</span>
              <span className="ai-type">{ai.personality}</span>
            </div>
            
            <div className="ai-weights">
              <h5>重視する基準:</h5>
              {ai.topCriteria.map((crit, idx) => (
                <span key={idx} className="top-criterion">{crit}</span>
              ))}
            </div>
            
            <div className="ai-activity">
              <span className="last-action">{ai.lastAction}</span>
              <span className="agreement-level">
                同意度: {(ai.agreementWithHuman * 100).toFixed(0)}%
              </span>
            </div>
          </div>
        ))}
      </div>
      
      <div className="consensus-progress">
        <h4>合意形成の進展</h4>
        <div className="progress-bar">
          <div 
            className="progress-fill"
            style={{width: `${consensusProgress * 100}%`}}
          ></div>
        </div>
        <span>{(consensusProgress * 100).toFixed(1)}% 合意達成</span>
      </div>
    </div>
  );
};
```

## ゲームメカニクス詳細

### 3.1 1ラウンドの流れ（60秒）
```javascript
async function executeRound(roundNumber) {
  // Phase 1: AI行動生成（同時実行）
  const aiActions = await Promise.all([
    generateAIAction(aiAgent1, gameState),
    generateAIAction(aiAgent2, gameState), 
    generateAIAction(aiAgent3, gameState)
  ]);
  
  // Phase 2: 人間への提案表示（20秒）
  const aiSuggestion = selectBestAISuggestion(aiActions);
  displayAISuggestion(aiSuggestion);
  
  const humanAction = await waitForHumanAction(20000); // 20秒タイムアウト
  
  // Phase 3: 全アクション実行
  const allActions = [...aiActions, humanAction];
  const results = executeAllActions(allActions);
  
  // Phase 4: 状態更新
  updateGameState(results);
  updateUI();
  
  // Phase 5: フィードバック表示（5秒）
  displayRoundResults(results);
  await delay(5000);
}
```

### 3.2 AI参加者の個性設定
```javascript
const aiPersonalities = [
  {
    id: 'ai1',
    name: 'アカデミックAI',
    personality: '学術重視型',
    baseWeights: [0.50, 0.15, 0.20, 0.15], // 学術レベル重視
    vetoIndex: 0, // 学術レベルがVeto
    behaviorPattern: 'conservative', // 慎重な提案
    description: '研究力や学術的な評判を最重視する'
  },
  {
    id: 'ai2', 
    name: 'プラクティカルAI',
    personality: '実用重視型',
    baseWeights: [0.15, 0.40, 0.15, 0.30], // 費用・就職重視
    vetoIndex: 1, // 費用がVeto
    behaviorPattern: 'aggressive', // 積極的な提案
    description: '費用対効果と就職実績を重視する現実的思考'
  },
  {
    id: 'ai3',
    name: 'バランスAI', 
    personality: 'バランス型',
    baseWeights: [0.25, 0.25, 0.25, 0.25], // バランス重視
    vetoIndex: 2, // 立地がVeto
    behaviorPattern: 'moderate', // 中庸な提案
    description: '全ての基準をバランスよく考慮する協調的性格'
  }
];
```

### 3.3 スコア計算システム
```javascript
function calculateScores(gameState) {
  const humanWeights = gameState.human.weights;
  const humanEvaluations = gameState.human.evaluations;
  const groupWeights = calculateGroupAverage(gameState.allWeights);
  const groupEvaluations = calculateGroupAverage(gameState.allEvaluations);
  
  // 個人効用ベクトル
  const personalUtility = matrixMultiply(humanEvaluations, humanWeights);
  
  // 集団効用ベクトル  
  const groupUtility = matrixMultiply(groupEvaluations, groupWeights);
  
  // Social Interest (相関係数)
  const socialInterest = pearsonCorrelation(personalUtility, groupUtility);
  
  // 合意度（L1距離の逆数）
  const consensus = 1.0 - l1Distance(humanWeights, groupWeights) / 2.0;
  
  // 最終スコア
  const personalSatisfaction = (socialInterest + 1.0) / 2.0; // [0,1]
  const groupHarmony = consensus; // [0,1]
  
  return {
    personalSatisfaction: personalSatisfaction * 100,
    groupHarmony: groupHarmony * 100,
    totalScore: (personalSatisfaction * 0.7 + groupHarmony * 0.3) * 100
  };
}
```

## Phase 3: 結果表示（2分）

### 4.1 最終結果画面
```javascript
const FinalResults = () => {
  const finalScores = calculateFinalScores();
  const finalRanking = calculateFinalRanking();
  
  return (
    <div className="final-results">
      <h2>🎯 ゲーム終了！</h2>
      
      <div className="score-summary">
        <div className="score-card personal">
          <h3>個人満足度</h3>
          <div className="score-value">{finalScores.personalSatisfaction.toFixed(1)}</div>
          <div className="score-description">
            あなたの選好とグループの選択の一致度
          </div>
        </div>
        
        <div className="score-card group">
          <h3>グループ調和度</h3>
          <div className="score-value">{finalScores.groupHarmony.toFixed(1)}</div>
          <div className="score-description">
            参加者間での価値観の合意度
          </div>
        </div>
        
        <div className="score-card total">
          <h3>総合評価</h3>
          <div className="score-value">{finalScores.totalScore.toFixed(1)}</div>
          <div className="score-grade">{getScoreGrade(finalScores.totalScore)}</div>
        </div>
      </div>
      
      <div className="final-ranking">
        <h3>🏆 最終大学ランキング</h3>
        <div className="ranking-table">
          {finalRanking.map((uni, rank) => (
            <div key={rank} className={`rank-row ${rank === 0 ? 'winner' : ''}`}>
              <span className="rank">#{rank + 1}</span>
              <span className="university">{uni.name}</span>
              <span className="score">{uni.score.toFixed(2)}</span>
              <span className="consensus">
                {uni.agreement > 0.8 ? '👥 高合意' : 
                 uni.agreement > 0.6 ? '🤝 中合意' : '🤔 低合意'}
              </span>
            </div>
          ))}
        </div>
      </div>
      
      <div className="performance-analysis">
        <h3>📊 パフォーマンス分析</h3>
        <div className="analysis-grid">
          <div className="metric">
            <span className="label">重み変更回数:</span>
            <span className="value">{gameStats.weightChanges}</span>
          </div>
          <div className="metric">
            <span className="label">AI提案受入率:</span>
            <span className="value">{(gameStats.aiAcceptanceRate * 100).toFixed(1)}%</span>
          </div>
          <div className="metric">
            <span className="label">最大合意度:</span>
            <span className="value">{(gameStats.maxConsensus * 100).toFixed(1)}%</span>
          </div>
          <div className="metric">
            <span className="label">決定時間平均:</span>
            <span className="value">{gameStats.avgDecisionTime.toFixed(1)}秒</span>
          </div>
        </div>
      </div>
    </div>
  );
};
```

## 技術実装仕様

### 5.1 サーバーサイド構成
```python
# Flask/FastAPI サーバー
class GameServer:
    def __init__(self):
        self.active_games = {}  # game_id -> GameInstance
        self.ai_models = load_pretrained_models()
        
    async def create_game(self, human_player_id):
        game = GameInstance(
            human_id=human_player_id,
            ai_agents=self.initialize_ai_agents(),
            duration=15*60  # 15分
        )
        self.active_games[game.id] = game
        return game.id
    
    async def process_human_action(self, game_id, action_data):
        game = self.active_games[game_id]
        
        # 1. 人間アクション処理
        human_action = parse_human_action(action_data)
        
        # 2. AI行動生成
        ai_observations = build_ai_observations(game.state)
        ai_actions = []
        for ai_agent in game.ai_agents:
            obs = ai_observations[ai_agent.id]
            action_logits = ai_agent.model(torch.tensor(obs))
            action_idx = torch.multinomial(F.softmax(action_logits), 1).item()
            ai_actions.append(action_space[action_idx])
        
        # 3. 環境ステップ実行
        all_actions = ai_actions + [human_action]
        results = step_environment(game.state, all_actions)
        
        # 4. 状態更新・結果返却
        game.update_state(results)
        return format_response(results, game.state)
```

### 5.2 クライアントサイド状態管理
```javascript
// React + WebSocket
class GameClient {
  constructor() {
    this.ws = new WebSocket('ws://localhost:8000/game');
    this.gameState = {
      round: 0,
      timeRemaining: 0,
      humanWeights: null,
      aiWeights: [],
      evaluations: null,
      scores: { personal: 0, group: 0 }
    };
  }
  
  async sendAction(actionData) {
    const message = {
      type: 'human_action',
      data: actionData,
      timestamp: Date.now()
    };
    this.ws.send(JSON.stringify(message));
  }
  
  handleServerUpdate(message) {
    const { type, data } = JSON.parse(message);
    
    switch(type) {
      case 'state_update':
        this.updateGameState(data);
        break;
      case 'ai_suggestion':
        this.displayAISuggestion(data);
        break;
      case 'round_complete':
        this.handleRoundComplete(data);
        break;
    }
  }
}
```

### 5.3 データ収集仕様
```python
# ログ収集・分析
@dataclass
class GameLog:
    session_id: str
    human_player_id: str
    timestamp: datetime
    round_number: int
    action_type: str  # 'weight_adjust' | 'eval_adjust'
    action_details: dict
    human_response_time: float
    ai_suggestions: list
    state_before: dict
    state_after: dict
    scores: dict
    
def log_game_event(game_id: str, event_data: dict):
    """全ての重要イベントをログに記録"""
    log_entry = GameLog(
        session_id=game_id,
        **event_data
    )
    
    # データベース保存
    db.save_log(log_entry)
    
    # リアルタイム分析
    analytics.update_metrics(log_entry)
```

## 実験計画

### 6.1 パイロット実験（n=10）
**目的**: システム安定性・UI/UX検証・基礎データ収集

**参加者条件**:
- 年齢: 18-35歳
- 学歴: 大学受験経験あり
- IT リテラシー: 中級以上（Web ブラウザゲーム経験）

**実施手順**:
```python
pilot_schedule = {
    "recruitment": "1週間（クラウドソーシング + 大学掲示板）",
    "pre_survey": "5分（基本属性・AHP経験・ゲーム経験）",
    "game_session": "25分（設定5分 + ゲーム20分）",
    "post_survey": "10分（満足度・UI評価・改善提案）",
    "follow_up": "1週間後（記憶に残った要素の確認）"
}
```

**重要測定項目**:
```python
pilot_metrics = {
    "technical": {
        "completion_rate": "> 90%",
        "system_errors": "< 5%", 
        "response_time": "< 3秒",
        "data_loss": "0%"
    },
    "usability": {
        "task_completion": "> 85%",
        "user_satisfaction": "> 4.0/5.0",
        "confusion_rate": "< 20%",
        "help_requests": "< 30%"
    },
    "gameplay": {
        "round_completion": "> 12/15",
        "action_diversity": "> 5 unique actions",
        "ai_acceptance": "30-70%",
        "final_consensus": "> 0.3"
    }
}
```

### 6.2 本実験設計（n=100）

#### A/B条件設定
```python
experimental_conditions = {
    "Condition_A_Baseline": {
        "name": "従来UI群",
        "interface": "スライダー式重み調整",
        "ai_support": None,
        "participants": 50,
        "goal": "ベースライン性能測定"
    },
    "Condition_B_AI_Assisted": {
        "name": "AI支援群", 
        "interface": "カード式AI提案システム",
        "ai_support": "learned_model_v1.0",
        "participants": 50,
        "goal": "AI支援効果の検証"
    }
}
```

#### 実験プロトコル
```python
def run_main_experiment():
    """本実験の実施プロトコル"""
    
    # Phase 1: 事前調査（10分）
    pre_experiment = {
        "demographics": ["age", "gender", "education", "major"],
        "decision_style": "5-factor questionnaire",
        "ahp_experience": "yes/no + detail",
        "ai_trust": "7-point Likert scale",
        "university_experience": "personal experience rating"
    }
    
    # Phase 2: 練習セッション（3分）
    practice_session = {
        "simplified_scenario": "2大学×3基準",
        "rounds": 3,
        "ai_opponents": "simplified_behavior",
        "feedback": "immediate explanations"
    }
    
    # Phase 3: 本ゲーム（15分）
    main_game = {
        "scenario": "3大学×4基準",
        "rounds": 12,
        "ai_opponents": "full_learned_behavior", 
        "condition": "assigned_randomly"
    }
    
    # Phase 4: 事後調査（15分）
    post_experiment = {
        "satisfaction": "game enjoyment, perceived fairness",
        "ai_evaluation": "helpfulness, trust, anthropomorphism",
        "strategy_reflection": "decision factors, learning",
        "ui_feedback": "usability, suggestions",
        "final_interview": "optional 5-minute video call"
    }
```

#### 詳細測定項目
```python
measurement_framework = {
    "primary_outcomes": {
        "decision_quality": {
            "personal_satisfaction": "final utility score [0-100]",
            "group_consensus": "L1 weight distance [0-1]", 
            "pareto_efficiency": "dominated solutions ratio",
            "consistency": "AHP CI score [0-0.2]"
        },
        "process_efficiency": {
            "time_to_convergence": "rounds until 80% consensus",
            "decision_time": "average time per action [sec]",
            "cognitive_load": "NASA-TLX questionnaire",
            "error_frequency": "invalid actions per session"
        }
    },
    
    "secondary_outcomes": {
        "human_ai_interaction": {
            "ai_acceptance_rate": "% of AI suggestions followed",
            "trust_evolution": "trust rating per round",
            "anthropomorphism": "perceived AI personality",
            "reliance_pattern": "dependency vs independence"
        },
        "learning_effects": {
            "strategy_adaptation": "action pattern changes",
            "meta_cognitive_awareness": "self-reported strategy",
            "transfer_potential": "post-hoc scenario evaluation"
        }
    },
    
    "exploratory_measures": {
        "individual_differences": {
            "personality": "Big-5 inventory (short form)",
            "decision_style": "General Decision Making Style",
            "need_for_cognition": "18-item scale",
            "technology_acceptance": "TAM questionnaire"
        },
        "behavioral_patterns": {
            "action_sequences": "Markov chain analysis",
            "response_timing": "keystroke dynamics",
            "attention_patterns": "eye-tracking (subset)",
            "physiological": "heart rate variability (subset)"
        }
    }
}
```

### 6.3 長期フォローアップ（n=50）

```python
longitudinal_study = {
    "timeline": {
        "baseline": "初回実験直後",
        "week_1": "1週間後（記憶定着）",
        "month_1": "1ヶ月後（実用性評価）",
        "month_3": "3ヶ月後（長期効果）"
    },
    
    "measurements": {
        "week_1": {
            "recall_test": "ゲーム要素・戦略の記憶",
            "attitude_change": "AI・集団意思決定への態度",
            "real_world_application": "類似状況での行動変化"
        },
        "month_1": {
            "tool_adoption": "類似ツールの使用意向",
            "skill_transfer": "実際の意思決定場面での応用",
            "recommendation": "他者への推奨意向"
        },
        "month_3": {
            "sustained_learning": "学習効果の持続性",
            "behavioral_change": "意思決定スタイルの変化",
            "system_improvement": "理想的な支援システム像"
        }
    }
}
```

## データ分析計画

### 7.1 統計解析手法
```python
analysis_pipeline = {
    "descriptive_analysis": {
        "participant_flow": "CONSORT diagram",
        "baseline_characteristics": "demographics + pre-measures",
        "gameplay_summary": "completion rates, time distributions"
    },
    
    "primary_analysis": {
        "treatment_effect": {
            "method": "mixed-effects regression",
            "outcome": "final_satisfaction_score",
            "predictors": ["condition", "round", "baseline_measures"],
            "random_effects": ["participant_id"],
            "effect_size": "Cohen's d with 95% CI"
        },
        "consensus_analysis": {
            "method": "multilevel survival analysis", 
            "outcome": "time_to_consensus",
            "covariates": ["ai_acceptance", "initial_diversity"],
            "clustering": "session_id"
        }
    },
    
    "secondary_analysis": {
        "mediation_analysis": {
            "mediator": "ai_trust_score",
            "path": "condition → trust → satisfaction",
            "method": "causal mediation analysis"
        },
        "moderation_analysis": {
            "moderator": "personality_factors",
            "interaction": "condition × openness → ai_acceptance",
            "method": "Johnson-Neyman technique"
        }
    },
    
    "exploratory_analysis": {
        "behavioral_clustering": {
            "method": "k-means clustering on action sequences",
            "features": ["weight_change_patterns", "timing_patterns"],
            "validation": "silhouette analysis"
        },
        "network_analysis": {
            "method": "temporal network analysis",
            "nodes": "decision_states",
            "edges": "state_transitions", 
            "metrics": ["centrality", "modularity"]
        }
    }
}
```

### 7.2 機械学習分析
```python
ml_analysis = {
    "predictive_modeling": {
        "task": "predict session success from early behavior",
        "features": "first 5 rounds action + response time",
        "models": ["random_forest", "xgboost", "neural_network"],
        "evaluation": "5-fold cross-validation, AUC-ROC"
    },
    
    "pattern_discovery": {
        "sequence_mining": {
            "method": "frequent pattern mining",
            "data": "action_sequences",
            "goal": "identify successful strategies"
        },
        "anomaly_detection": {
            "method": "isolation_forest",
            "data": "behavioral_features", 
            "goal": "identify unusual participants"
        }
    },
    
    "natural_language_processing": {
        "feedback_analysis": {
            "method": "sentiment analysis + topic modeling",
            "data": "post_experiment_comments",
            "tools": ["VADER", "LDA", "BERT"]
        }
    }
}
```

## 品質保証・倫理的配慮

### 8.1 実験品質管理
```python
quality_assurance = {
    "technical_validation": {
        "code_review": "peer review + automated testing",
        "security_audit": "penetration testing + data encryption",
        "performance_testing": "load testing up to 100 concurrent users",
        "browser_compatibility": "Chrome, Firefox, Safari, Edge"
    },
    
    "experimental_validity": {
        "internal_validity": {
            "randomization_check": "baseline balance testing",
            "manipulation_check": "condition recognition quiz",
            "attention_check": "embedded validity questions"
        },
        "external_validity": {
            "sample_representativeness": "quota sampling by demographics",
            "scenario_realism": "expert validation by university counselors",
            "ecological_validity": "follow-up real-world application study"
        }
    },
    
    "data_quality": {
        "real_time_monitoring": "automated anomaly detection",
        "missing_data_strategy": "multiple imputation + sensitivity analysis", 
        "outlier_treatment": "robust statistics + manual review",
        "reproducibility": "containerized environment + version control"
    }
}
```

### 8.2 倫理的配慮
```python
ethical_framework = {
    "informed_consent": {
        "disclosure": "AI involvement, data usage, time commitment",
        "voluntary_participation": "withdrawal option without penalty",
        "compensation": "fair payment (¥1,500 for 40min session)",
        "privacy_protection": "anonymization + secure storage"
    },
    
    "risk_mitigation": {
        "psychological_safety": "no deceptive AI personas",
        "data_security": "GDPR-compliant practices",
        "algorithmic_fairness": "bias testing across demographics",
        "transparency": "AI decision process explanation"
    },
    
    "institutional_review": {
        "irb_approval": "university ethics committee review",
        "data_governance": "institutional data sharing agreement", 
        "conflict_of_interest": "researcher independence statement",
        "publication_plan": "pre-registration + open data policy"
    }
}
```

## 期待される成果・インパクト

### 9.1 学術的貢献
```python
academic_contributions = {
    "theoretical_advances": {
        "human_ai_collaboration": "新しい協調意思決定モデル",
        "computational_social_choice": "AI支援下での集合知能",
        "behavioral_economics": "群衆知性における認知バイアス軽減"
    },
    
    "methodological_innovations": {
        "experimental_paradigm": "リアルタイムマルチエージェント実験",
        "measurement_framework": "ゲーミフィケーション×厳密測定",
        "analysis_techniques": "時系列ネットワーク分析手法"
    },
    
    "empirical_findings": {
        "learning_transfer": "p2p学習→人間環境での有効性",
        "individual_differences": "AI支援効果の個人差要因",
        "process_mechanisms": "合意形成の認知的・社会的メカニズム"
    }
}
```

### 9.2 実用的応用
```python
practical_applications = {
    "decision_support_systems": {
        "corporate_strategy": "経営会議での戦略決定支援",
        "public_policy": "市民参加型政策立案プラットフォーム",
        "healthcare": "医療チームでの治療方針決定"
    },
    
    "educational_tools": {
        "business_schools": "意思決定論・ゲーム理論の実習",
        "continuing_education": "リーダーシップ研修プログラム",
        "online_learning": "協調学習プラットフォーム"
    },
    
    "technology_transfer": {
        "software_products": "群集意思決定SaaSサービス",
        "consulting_services": "組織開発・ファシリテーション",
        "research_infrastructure": "オープンソース実験プラットフォーム"
    }
}
```

### 9.3 社会的インパクト
```python
social_impact = {
    "democratic_participation": {
        "civic_engagement": "市民参加の質的向上",
        "digital_democracy": "オンライン合意形成の新手法",
        "social_cohesion": "異なる価値観の建設的統合"
    },
    
    "organizational_effectiveness": {
        "team_performance": "チーム意思決定の質的向上",
        "conflict_resolution": "価値観対立の建設的解決",
        "innovation_facilitation": "創発的アイデア生成支援"
    },
    
    "ai_society_integration": {
        "human_ai_coexistence": "対立ではない協調関係のモデル",
        "algorithmic_governance": "透明で参加型のAI意思決定",
        "digital_literacy": "AI時代の市民スキル向上"
    }
}
```

この詳細仕様により、p2p.pyで実現した学習成果（J=0.0869, D_final=0.251）を人間参加環境で検証し、さらに実社会での応用可能性を探ることができます。特に、**AI学習戦略の人間環境での転移性**という重要な研究課題に対して、厳密で包括的な実証的回答を提供することが期待されます。


# 人間中心の成功指標：AI支援による人間の意思決定改善

## 基本認識の修正

### ❌ **間違った成功定義**
- 「グループ全体の指標が良くなる」
- 「学習済みAI3体が引っ張るので当然改善する」
- 「集団効用や合意度の向上」

### ✅ **正しい成功定義** 
- 「人間1名の意思決定が改善する」
- 「AI支援により人間がより良い判断をする」
- 「人間の満足度・学習・適応が向上する」

## 人間中心の成功指標

### 1. 【Primary Human Outcomes】人間の意思決定品質

#### 1.1 人間の個人効用最適化
```python
human_decision_quality = {
    "personal_utility_maximization": {
        "definition": "人間自身の効用関数に対する最適化度",
        "measurement": "human_S @ human_w (人間の評価×人間の重み)",
        "comparison": "AI支援あり vs AI支援なし",
        "target": "AI支援条件で10%以上の改善",
        "formula": "(utility_with_ai - utility_without_ai) / utility_without_ai"
    },
    
    "preference_consistency": {
        "definition": "人間の選好の内的整合性",
        "measurement": "AHP整合性指標（CI値）の改善",
        "comparison": "初期CI vs 最終CI",
        "target": "CI値の有意な改善（p<0.05）",
        "interpretation": "AI支援により論理的一貫性向上"
    },
    
    "decision_confidence": {
        "definition": "人間の決定への確信度",
        "measurement": "各ラウンド後の確信度評価（1-7スケール）",
        "comparison": "AI支援あり vs なし条件",
        "target": "AI支援条件で確信度 > 5.5",
        "pattern": "時系列での確信度向上パターン"
    }
}
```

#### 1.2 人間の学習・適応
```python
human_learning_metrics = {
    "strategy_improvement": {
        "definition": "人間の戦略の洗練化",
        "measurement": "行動パターンの収束・効率化",
        "indicators": [
            "decision_time_reduction",  # 決定時間の短縮
            "exploration_vs_exploitation",  # 探索-活用バランス
            "error_correction_speed"  # ミス修正の迅速化
        ],
        "target": "AI支援により学習カーブが急勾配化"
    },
    
    "meta_cognitive_development": {
        "definition": "意思決定についての理解深化",
        "measurement": "事後質問紙・インタビュー",
        "dimensions": [
            "criterion_importance_clarity",  # 基準重要度の明確化
            "tradeoff_understanding",  # トレードオフ理解
            "group_dynamics_awareness"  # 集団力学への気づき
        ],
        "target": "AI支援により自己理解が深化"
    }
}
```

### 2. 【Human Experience Metrics】人間の体験品質

#### 2.1 主観的満足度
```python
satisfaction_metrics = {
    "outcome_satisfaction": {
        "definition": "最終決定への満足度",
        "measurement": "事後質問「この決定に満足している」(1-7)",
        "comparison": "AI支援あり vs なし",
        "target": "AI支援条件で満足度 > 5.5",
        "success": "有意差 + 効果量d > 0.5"
    },
    
    "process_satisfaction": {
        "definition": "決定過程への満足度", 
        "measurement": "「この決定方法は良かった」(1-7)",
        "target": "AI支援条件で満足度 > 5.0",
        "components": ["fairness", "transparency", "autonomy"]
    },
    
    "ai_collaboration_satisfaction": {
        "definition": "AI協働への満足度",
        "measurement": "「AIとの協働は有益だった」(1-7)",
        "target": "> 5.0",
        "predictors": ["trust", "perceived_usefulness", "ease_of_use"]
    }
}
```

#### 2.2 認知負荷・ストレス
```python
cognitive_metrics = {
    "perceived_difficulty": {
        "definition": "タスクの困難度認知",
        "measurement": "NASA-TLX困難度サブスケール",
        "expectation": "AI支援により困難度が軽減",
        "target": "AI支援条件で困難度 < 50/100"
    },
    
    "decision_stress": {
        "definition": "決定に伴うストレス",
        "measurement": "「ストレスを感じた」(1-7 逆転)",
        "target": "AI支援条件でストレス軽減",
        "physiological": "HRV, 皮膚コンダクタンス（オプション）"
    },
    
    "information_overload": {
        "definition": "情報過多感",
        "measurement": "「情報が多すぎて困った」(1-7)",
        "concern": "AI支援により情報過多にならないか",
        "target": "適切な情報量（3-4レベル）"
    }
}
```

### 3. 【Human Behavior Metrics】人間の行動変化

#### 3.1 行動の質的改善
```python
behavioral_improvement = {
    "action_appropriateness": {
        "definition": "選択行動の適切性",
        "measurement": "専門家評価による行動の合理性スコア",
        "method": "シナリオ後の行動系列を専門家3名が評価",
        "scale": "1-10点",
        "target": "AI支援条件で適切性スコア > 7.0"
    },
    
    "exploration_efficiency": {
        "definition": "探索行動の効率性",
        "measurement": "有用な情報への到達速度",
        "indicators": [
            "重要基準への早期注目",
            "無駄な調整の減少", 
            "効果的な実験の実行"
        ],
        "target": "AI支援により効率的探索"
    },
    
    "adaptation_speed": {
        "definition": "環境変化への適応速度",
        "measurement": "新情報への反応時間・適切性",
        "scenario": "ゲーム中盤でのルール変更に対する対応",
        "target": "AI支援により迅速で適切な適応"
    }
}
```

#### 3.2 社会的行動の変化
```python
social_behavior = {
    "cooperative_tendency": {
        "definition": "協調行動の傾向",
        "measurement": "集団利益を考慮した行動の頻度",
        "operationalization": "自己犠牲的選択の回数",
        "target": "AI支援により協調性向上"
    },
    
    "communication_quality": {
        "definition": "他者との相互作用品質",
        "measurement": "AI提案への理由付け・説明要求",
        "indicators": ["質問の質", "理解確認", "建設的反応"],
        "target": "AI支援により相互作用が建設的に"
    }
}
```

## 比較ベースラインの設計

### 人間パフォーマンスの適切な比較

#### 比較条件A: ランダムAI環境
```python
baseline_random_ai = {
    "setup": "人間1名 + ランダム行動AI 3名",
    "ai_behavior": "180アクションからランダム選択",
    "purpose": "学習済みAI の特異性を検証",
    "expected": "人間パフォーマンスは低位安定"
}
```

#### 比較条件B: ルールベースAI環境  
```python
baseline_rule_ai = {
    "setup": "人間1名 + 単純ルールAI 3名",
    "ai_behavior": "重み均等化・評価平均化の単純ルール",
    "purpose": "学習の必要性を検証",
    "expected": "中程度のパフォーマンス"
}
```


## 具体的な成功判定基準

### 🎯 **Tier 1: 基本的効果（必須）**
```python
tier1_success = {
    "human_utility_improvement": "> 5%",
    "decision_confidence": "> 5.0/7", 
    "outcome_satisfaction": "> 5.0/7",
    "statistical_significance": "p < 0.05"
}
```

### 🎯 **Tier 2: 実用的効果（期待）**
```python
tier2_success = {
    "human_utility_improvement": "> 10%",
    "learning_evidence": "strategy_improvement_detected",
    "process_satisfaction": "> 5.5/7",
    "effect_size": "Cohen's d > 0.5"
}
```

### 🎯 **Tier 3: 変革的効果（理想）**
```python
tier3_success = {
    "human_utility_improvement": "> 20%",
    "meta_cognitive_development": "significant_insights_gained",
    "sustained_learning": "post_experiment_transfer",
    "individual_optimization": "personalized_ai_support_identified"
}
```

## 分析焦点の転換

### 従来の分析（グループレベル）
```python
# ❌ これは当然良くなる
group_metrics = {
    "group_consensus": "学習済みAI3体で当然向上",
    "group_utility": "最適化されたAIで当然向上", 
    "convergence_speed": "訓練済みで当然高速"
}
```

### 新しい分析（人間レベル）
```python
# ✅ これが真の検証対象
human_focused_analysis = {
    "within_human_improvement": "同一人間のbefore/after比較",
    "human_vs_baseline": "AI支援あり/なしでの人間パフォーマンス比較",
    "human_learning_curve": "人間の時系列改善パターン",
    "individual_differences": "どのような人がAI支援で最も向上するか"
}
```

## 実装上の重要な変更

### データ収集の焦点変更
```python
data_collection_priority = {
    "high_priority": [
        "human_action_sequences",  # 人間の行動パターン
        "human_decision_times",    # 人間の思考時間
        "human_satisfaction_ratings",  # 人間の主観評価
        "human_learning_indicators"    # 人間の学習証拠
    ],
    "medium_priority": [
        "human_ai_interaction_patterns",  # 人間-AI相互作用
        "human_strategy_evolution",       # 人間の戦略変化
        "human_confidence_trajectories"   # 人間の確信度変化
    ],
    "low_priority": [
        "group_level_metrics",  # グループ指標（参考程度）
        "ai_performance_metrics"  # AI性能（統制確認用）
    ]
}
```

この修正により、実験の成功は**「人間がAI支援によってより良い意思決定者になったか」**という明確で意味のある基準で判定できます。学習済みAIが優秀なのは前提条件であり、重要なのは**その優秀さが人間の能力向上に寄与するか**です。